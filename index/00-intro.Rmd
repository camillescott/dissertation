<!-- The {.unnumbered} option here means that the introduction will be "Chapter 0." You can also use {-} for no numbers on chapters. -->

# Introduction {#intro}

## Motivation

* Scaling sequence analysis
* Improving accessibility
* Overly-deep pipelines / intermediate data
* Sea-change toward streaming methods due to nanopore

## Background

* Sequencing technology
    * Second-gen HTS: illumina
    * Long read tech: pacbio
    * Real-time sequencing: nanopore
* Streaming Algorithms
    * Definitions
        * Offline algs
        * semi-streaming algs
    * Advantages
        * Implied dynamic data structures
        * Disk space efficiency
        * Removal of intermediate output
        * Infinite-size data
        * Real-time analysis
    * In \*omics
        * Hardware level: ONT
        * Abundance estimation
        * Classification (signatures)
        * k-mer cardinality
        * k-mer statistics (kmerstream)
        * assembly (semi-streaming)
        * scaffolding
* de Bruijn Graphs
    * Motivation / Uses
        * exact overlap detection
        * assembly
        * classification
        * sequence comparison
        * graph alignment
    * Definitions
        * k-mers
        * node vs edge centric
        * neighbor-finding
        * bidirectional dBG
        * traversal
    * Representations
        * Offline
            * Suffix trees
            * FM-index
            * bitmaps
            * BF + crit false positives
            * cascading BF
        * Streaming
            * (exact) hash tables
            * bloom filters
            * count-min sketch
            * quotient filter
    * Tagging / partitioning
        * Why
            * seeding for traversal
            * alignment-free comparison
            * locking / parallel construction
            * sparse-graph construction
        * Greedy k-mer subset (khmer, SparseAssembler)
        * (W,K) Minimizers
        * r-dom sets
        * Universal k-mer hitting sets
    * Implementations: offline
        * So many k-mer counters
        * GATB
        * So many assemblers: AbySS, velvet, IDBA, megahit, ALLPATHS
    * Implementations: streaming
        * khmer/oxli
* compact de Bruijn graphs
    * Motivation
        * Compressed dBG representation
        * Preserve dBG properties: implicit edges
    * Definitions:
        * From "chunks" (OLC) to dBG models
        * decision k-mers
        * Unitigs
        * Maximal unitigs
        * Simpletigs
    * Implementations: offline
        * BCALM
        * TwoPaCo
        * As components of assemblers: Abyss, etc
    * Implementations: semi-streaming
        * Faucet
        * LightAssembler
* saturation
    * Definitions of saturation
        * Accumulation of information vs error
        * by minimizing fragmentation
        * by coverage profile
        * by completeness: gene content, etc (BUSCO)
    * By context
        * Genomic vs txomic vs mtomic
        * downstream goals: assembly, classifcation, abundance
* Sketching