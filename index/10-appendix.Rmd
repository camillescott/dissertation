`r if(knitr:::is_latex_output()) '\\appendix'`

`r if(!knitr:::is_latex_output()) '# (APPENDIX) Appendix {-}'` 

<!--
If you feel it necessary to include an appendix, it goes here.
-->

# The `goetia` Library and Software

`goetia` is an open source software package implementing the methods described in this dissertation.
It comprises three main components:
1. A C++ library, `libgoetia`, which implements $k$-mer storage and hashing, de Bruijn graph traversal, file and stream sequence parsing, sketch construction, and sequence filtering;2
2. A set of Python bindings for `libgoetia`, generated with `cppyy` [@doi:10.1109/PyHPC.2016.008], which expose the library in a user friendly form;
3. A Python library implementing asynchronous interaction with `libgoetia`'s various processors, the `goetia` command-line interface, and a suite of unit tests.

All code is released under the MIT license and hosted on GitHub [@url:https://github.com/camillescott/goetia].
The package is distributed via the `conda` ecosystem on the `bioconda` channel [@doi:10.1038/s41592-018-0046-7].
Due to the complexity of the build process introduced by `cppyy`, the package is not currently distributed on PyPI; distribution on PyPI may be explored in the future if the effort appears worthwhile.

## `libgoetia`

The C++ library is responsible for the "heavy lifting" of the package.
To enable composibility and efficiency, it makes much use of of templating and the curiously-recurring template pattern (CRTP) to avoid virtual function calls.
The library is organized into namespaces by purpose.

## Hashing

$k$-mer hashing is a core bottleneck in de Bruijn graph construction, as well as many sketching algorithms.
Because of the centrality of hashing, many of `goetia`'s classes are parameterized by hashing method.
Hashing capability is modularized; the basic interfaces simply accept $k$-mer sequences and produce integers, and additional, more advanced interfaces support efficient rolling hashing and neighbor-searching.

### Hash types

The types of hash values are templated to allow composability and flexibility.
The core type is `Hash`, which is parametrized with a `value_type` for the underlying integer to be used.
Casting to `value_type` or calling `value()` on a `Hash` object will return the underlying integer.
Generally, this is assumed to be `uint64_t`, which is the default, but larger (or smaller) integers can be substituted.
Next is type `Canonical`, which like `Hash` takes a `value_type`, but actually stores two values: the forward and reverse-complement hash values.
When a `Canonical` is cast to `value_type` or hash its `value()` method called, it returns to smaller of its forward and reverse-complment hash values.

Building on the two foundational hash types is `Kmer`.
This is parameterized by a hash type corresponding to the interface of `Hash`, and stores a `std::string` corresponding to the $k$-mer associated with the hash value.
Related is the `Shift`: this also takes a hash type template parameter, as well as a non-type parameter of type `bool` for its direction.
A shift stores a hash value and a single `char` symbol representing the single base from the dBG alphabet $\Sigma$ that was added to the $k-1$ suffix (or prefix) of the `Shift`'s predecessor.

Finally, the `Partitioned` and `Wmer` templates are used for minimizer schemes.
A `Partitioned` models an underlying hash value with `hash_type` and an abritrary associated `uint64_t` partition ID, which may be calculated via minimizer, universal hitting set, or other methods.
`Wmer` stores a `Hash` along with a `Partitioned` to model the hash value of a full length $W$-mer, the hash value of its associated minimizer $k$-mer, and the partitioned ID of that minimizer $k$-mer.

### Hashers

$W$ and $k$-mer hashing algorithms are built on a standard interface for roll hash functions useful for $k$-mer hashing.
The foundation for this interface is the `HashShifter`, which takes as a template parameter a shift policy implementing the specific rolling hashing algorithm, and requires the following methods be defined on this policy:

- `get()`: Return the current hash value.
- `shift_right(char, char)`, `shift_left(char, char)`: Remove a character from the current state and hash in a new character.
- `hash_base(char *)`: Hash an entire $k$-mer (set the starting state before shifting).
- `static hash(char *)`: Statelessly hash an entire $k$-mer.

`HashShifter` is also templated with an `Alphabet`, which may be one of the plain nucleotides $\{A,C,G,T\}$, called `DNA_SIMPLE`, the plain nucleotides plus $\{N\}$,  called `DNAN_SIMPLE`, and the full IUPAC defined nucleotide alphabet `IUPAC_NUCL`.
The alphabet classes define their own validation and complementation methods.

There are specialized policies for: the Lemire rolling hash algorithm, for both `Hash` and `Canonical` (ie, strand-aware and canonical $k$-mer versions), and the rolling UHS minimizer shifter, which yields `Wmer` objects with their associated hitting $k$-mers instead of plain `Hash` objects.

Finally, to help build toward de Bruijn graph traversal, there is the `HashExtender` template.
The `HashExtender` has the hash state via its parent `HashShifter` while also adding a character ring buffer to track the current $k$-mer of its hash, which we call the cursor.
It extends the `HashShifter::shift_left` and `HashShifter::shift_right` methods to update this buffer, and also implements the `left` and `right_extensions` interfaces for generating the $\|\Sigma\|$ possible prefix or suffix neighbors of a $k$-mer.

## $k$-mer Storage

Storage classes implement efficient $k$-mer collections.
All follow a base interface named `Storage`, which takes a template parameter `value_type` for the type of the hashed $k$-mers to be stored.
The interface defines the following core methods:

- `insert(value_type)`: Insert an item into the collection, incrementing the associated counter if supported, and returns `true` if the item is newly observed.
- `insert_and_query(value_type)`: Perform an `insert` and return the count after insertion.
- `query(value_type)`: Retrieve the existence or count of the item.
- `n_unique_kmers()`: Report the number of unique elements in the collection.
- `reset()`: Remove all elements from the collection and return to default state.

Collections implementing the interface also define the following traits:

- `is_counting`: Whether the collection supports abundance counts or only behaves as a set.
- `is_probabilistic`: Whether the collection tracks items exactly or with error.
- `bits_per_slot`: Number of bits used per item, for bit-vector based data structures.
- `params_type`: Tuple for the parameter types needed to instantiate the class.
- `default_params`: Default parameters to use if not supplied.

`goetia` provides a number of data structures implementing this interface.

### Basic Storage Classes

##### Bloom filter: `BitStorage`

A Bloom filter is a probabilistic, sub-linear space data structure for set membership testing.
It uses reduced space at the cost of a small, predictable false positive rate, with no false negatives.
Memory usage is fixed; it is parameterized by size of its underlying bit vector and a number of hash functions, the two of which together decide the false positive rate [@doi:10.1145/362686.362692].
It is not possible the enumerate the members of a Bloom filter.
The Bloom filter code is a modified version of that in the `khmer` [@doi:10.12688/f1000research.6924.1] library.

##### Count-min sketch: `NibbleStorage` and `ByteStorage`

A Count-Min sketch [@doi:10.1145/362686.362692] is another probabilistic, sub-linear space data structure.
It operates similarly to the Bloom filter, but stores an approximate count of its items instead of simple presence.
`NibbleStorage` uses 4-bit counters, while `ByteStorage` uses 8-bit counters.
These too are modified versions of the those found in `khmer`.

##### `Sparsepp` Hash Set: `SparseppSetStorage`

An exact set representation using the `Sparsepp` hash table [@url:https://github.com/greg7mdp/sparsepp].
`Sparsepp` is an iteration on Google's `sparsehash` [@https://github.com/sparsehash/sparsehash], and provides a highly memory-efficient set with fast $O(1)$ insertions and queries.

##### `parallel-hashmap`: `PHMapStorage`

Another exact set representation using the `parallel-hashmap` library [@url:https://github.com/greg7mdp/parallel-hashmap].
Written by the same authors as a successor `Sparsepp`, it is an essentially unilateral improvement.
It uses SIMD instructions for internal probing and is optionally thread-safe.
`PHMapStorage` is the recommended (and default) exact store.

##### Counting Quotient Filter: `QFStorage`

A probabilistic sub-linear space data structure developed as a unilateral improvement over Count-min Sketches [@doi:10.1145/3035918.3035963].
It makes use of SIMD instructions to speed up rank-and-select operations and has good cache locality, the latter a significant weakness of Bloom filters and CM sketches.
These advantages are achieved at a considerable increase in implementation complexity.

### Partitioned Storage {#app-partitioned-storage}

The `PartitionedStorage` exposes the same interface as the basic `Storage`, but supports partitioning the underlying data into disjoint sets.
The API is agnostic to the method of partitioning; all that is required is a number of partitions and an additional parameter specifying the partition in which to store an item while inserting and querying.
The `PartitionedStorage` is template-parameterized with one of the formerly described storage classes, and a number of data structures equal to the number of partitions are constructed.
Thus, care must be taken when using underlying storage classes with a fixed, pre-allocated amount of memory, so as to not over-allocate available system memory.
The expected  partitioning method for $k$-mers are minimizer methods, particularly the Universal $k$-mer Hitting Set (UHS), which is part of the hashing functionality.

Partitioned storage offers several advantages, at the cost of increased processing time spent on determining partitions.
For storages with poor cache locality, an appropriately-determined partitioning methodology can reduce cache misses during query and graph traversal.
Partitioning also allows fine-grained per-partition locking of the dBG, and thus efficient parallel algorithms.
Both these advantages necessitate locality-sensitive partitioning methods such as minimizer and UHS schemes.
UHS schemes used for partitioning are described in \@ref(chap2-methods).

## de Bruijn Graphs

The `goetia::dBG` and `goetia::PdBG` classes build on the `Storage`, `PartitionedStorage`, and hashing classes to implement functional de Bruijn graphs.
The core `dBG` and `PdBG` interface defines:

- `insert(std::string)`: to hash and add an individual $k$-mer to the graph via the underlying `Storage` class.
- `insert_and_query(std::string)`: To add a $k$-mer and return its count post-insertion.
- `query(std::string)`: to retrieve the current presence or count of a $k$-mer.
- `insert_sequence(std::string`: To insert the $k$-mers of a sequence into the graph, along with a number of overloads for returning hashes, returning the set of new $k$-mers, return the vector of counts, and so on.

`dBG` and `PdBG` inherit the functionality of the `HashShifter`, `HashExtender`, and `UnitigWalker` classes, the latter of which is described below; hence, `dBG` also is capable of traversing itself.

The `cDBG` class is templated on a `dBG` type, and hence a `HashShifter` type, and implements the storage and retrieval of unitigs in its associated de Bruijn graph.
The `cDBG` class only manages the unitigs via their tips and the decision $k$-mers; the compacted graph is build using the `StreamingCompactor` class, which puts together all the prior functionality. Its primary public interface is simply the `insert_sequence` method, which adds a sequence to the underlying de Bruijn graph and appropriately updates the unitigs in the `cDBG` that the sequence intersects.

## de Bruijn Graph Traversal

The apex of the `HashShifter` and `dBG` hierarchy is the `UnitigWalker`.
It uses the functionality of the `HashExtender` to walk a `dBG` that is bound to it and extract unitigs.
It reports detailed state information its primary interfaces in the form of the `Walk` class, which defines:

- `kmer_type start`: A `Kmer` representing the start point of the traversal.
- `vector<Shift> path`: A vector of `Shift` representing the path taken by the traversal.
- `TraversalState end_state`: An `enum` holding the reason a traversal was terminated.

From this information, a walk can be converted to a unitig via its `to_string` method.
`TraversalState` can have the following values:

- `STOP_FWD`: There was no neighbor to traverse to (in or out-degree of zero).
- `DECISION_FWD`: Traversal stopped at a decision $k$-mer with in/out degree greater than one in the direction of traversal.
- `DECISION_BKW`: Traversal passed through a decision $k$-mer with degree greater than one in the opposite direction of traversal, and so backed off by one $k$-mer.
- `STOP_SEEN`: Traversal stopped because it hit a $k$-mer already seen in this traversal: ie, it formed a perfect loop.
- `STOP_MASKED`: Traversal stopped because it hit a $k$-mer in the explicit set of provided $k$-mers to stop at.
- `STOP_CALLBACK`: Traversal stopped because it was ordered to by a bound callback function.
- `BAD_SEED`: Traversal did not start in the first place because the start $k$-mer was not the underlying de Bruijn graph.
- `GRAPH_ERROR`: Some fatal error in the graph topology occurred.
- `STEP`: Traversal was able to successfully take a step (a single neighbor in the direction of traversal with no reverse decision node).

The `UnitigWalker` itself defines `filter_nodes`, which takes a list of extensions from `HashExtender` and removes those that are not in the associated graph and `in_neighbors` and `out_neighbors` to wrap `filter_nodes` with the current cursor of `HashExtender`.
For movement around the graph, it defines:

- `step_left`, `step_right`: Attempt to take a single step in the given direction, and return a resulting `TraversalState` and list of neighbors.
- `walk_left`, `walk_right`: Repeatedly step in the given direction and continue until a stop state is reached, returning a `Walk`.
- `walk`: Walk bidirectionally and return both walks.

The `dBG` and `PdBG` classes inherit from this class as a mixin, and so all this functionality (and state) is also found on a given `dBG` object.
`UnitigWalker` can be instantiated with an existing `dBG` or `PdBG` by passing a pointer to its constructor.

<!--

## Sketches

## Sequence Parsing and Processors

## General Utilities

-->
