`r if(knitr:::is_latex_output()) '\\appendix'`

`r if(!knitr:::is_latex_output()) '# (APPENDIX) Appendix {-}'` 

<!--
If you feel it necessary to include an appendix, it goes here.
-->


# `goetia`

`goetia` is an open source software package implementing the methods described in this dissertation.
It comprises three main components:
1. A C++ library, `libgoetia`, which implements $k$-mer storage and hashing, de Bruijn graph traversal, file and stream sequence parsing, sketch construction, and sequence filtering;2
2. A set of Python bindings for `libgoetia`, generated with `cppyy` [@doi:10.1109/PyHPC.2016.008], which expose the library in a user friendly form;
3. A Python library implementing asynchronous interaction with `libgoetia`'s various processors, the `goetia` command-line interface, and a suite of unit tests.

All code is released under the MIT license and hosted on GitHub [@url:https://github.com/camillescott/goetia].
The package is distributed via the `conda` ecosystem on the `bioconda` channel [@doi:10.1038/s41592-018-0046-7].
Due to the complexity of the build process introduced by `cppyy`, the package is not currently distributed on PyPI; distribution on PyPI may be explored in the future if the effort appears worthwhile.

## `libgoetia`

The C++ library is responsible for the "heavy lifting" of the package.
To enable composibility and efficiency, it makes much use of of templating and the curiously-recurring template pattern (CRTP) to avoid virtual function calls.
The library is organized into namespaces by purpose.

### `goetia::hashing`

$k$-mer hashing is a core bottleneck in de Bruijn graph construction, as well as many sketching algorithms.
Because of the centrality of hashing, many of `goetia`'s classes are parameterized by hashing method.
Hashing capability is modularized; the basic interfaces simply accept $k$-mer sequences and produce integers, and additional, more advanced interfaces support efficient rolling hashing and neighbor-searching.

#### Hash types

The types of hash values are templated to allow composability and flexibility.
The core type is `Hash`, which is parametrized with a `value_type` for the underlying integer to be used.
Casting to `value_type` or calling `value()` on a `Hash` object will return the underlying integer.
Generally, this is assumed to be `uint64_t`, which is the default, but larger (or smaller) integers can be substituted.
Next is type `Canonical`, which like `Hash` takes a `value_type`, but actually stores two values: the forward and reverse-complement hash values.
When a `Canonical` is cast to `value_type` or hash its `value()` method called, it returns to smaller of its forward and reverse-complment hash values.

Building on the two foundational hash types is `Kmer`.
This is parameterized by a hash type corresponding to the interface of `Hash`, and stores a `std::string` corresponding to the $k$-mer associated with the hash value.
Related is the `Shift`: this also takes a hash type template parameter, as well as a non-type parameter of type `bool` for its direction.
A shift stores a hash value and a single `char` symbol representing the single base from the dBG alphabet $\Sigma$ that was added to the $k-1$ suffix (or prefix) of the `Shift`'s predecessor.

### `goetia::storage`

Storage classes implement efficient $k$-mer collections.
All follow a base interface named `Storage`, which takes a template parameter `value_type` for the type of the hashed $k$-mers to be stored.
The interface defines the following core methods:

- `insert(value_type)`: Insert an item into the collection, incrementing the associated counter if supported, and returns `true` if the item is newly observed.
- `insert_and_query(value_type)`: Perform an `insert` and return the count after insertion.
- `query(value_type)`: Retrieve the existence or count of the item.
- `n_unique_kmers()`: Report the number of unique elements in the collection.
- `reset()`: Remove all elements from the collection and return to default state.

Collections implementing the interface also define the following traits:

- `is_counting`: Whether the collection supports abundance counts or only behaves as a set.
- `is_probabilistic`: Whether the collection tracks items exactly or with error.
- `bits_per_slot`: Number of bits used per item, for bit-vector based data structures.
- `params_type`: Tuple for the parameter types needed to instantiate the class.
- `default_params`: Default parameters to use if not supplied.

`goetia` provides a number of data structures implementing this interface.

#### Basic Storage Classes

##### Bloom filter: `BitStorage`

A Bloom filter is a probabilistic, sub-linear space data structure for set membership testing.
It uses reduced space at the cost of a small, predictable false positive rate, with no false negatives.
Memory usage is fixed; it is parameterized by size of its underlying bit vector and a number of hash functions, the two of which together decide the false positive rate [@doi:10.1145/362686.362692].
It is not possible the enumerate the members of a Bloom filter.
The Bloom filter code is a modified version of that in the `khmer` [@doi:10.12688/f1000research.6924.1] library.

##### Count-min sketch: `NibbleStorage` and `ByteStorage`

A Count-Min sketch [@doi:10.1145/362686.362692] is another probabilistic, sub-linear space data structure.
It operates similarly to the Bloom filter, but stores an approximate count of its items instead of simple presence.
`NibbleStorage` uses 4-bit counters, while `ByteStorage` uses 8-bit counters.
These too are modified versions of the those found in `khmer`.

##### `Sparsepp` Hash Set: `SparseppSetStorage`

An exact set representation using the `Sparsepp` hash table [@url:https://github.com/greg7mdp/sparsepp].
`Sparsepp` is an iteration on Google's `sparsehash` [@https://github.com/sparsehash/sparsehash], and provides a highly memory-efficient set with fast $O(1)$ insertions and queries.

##### `parallel-hashmap`: `PHMapStorage`

Another exact set representation using the `parallel-hashmap` library [@url:https://github.com/greg7mdp/parallel-hashmap].
Written by the same authors as a successor `Sparsepp`, it is an essentially unilateral improvement.
It uses SIMD instructions for internal probing and is optionally thread-safe.
`PHMapStorage` is the recommended (and default) exact store.

##### Counting Quotient Filter: `QFStorage`

A probabilistic sub-linear space data structure developed as a unilateral improvement over Count-min Sketches [@doi:10.1145/3035918.3035963].
It makes use of SIMD instruction to speed up rank-and-select operations and has good cache locality, the latter a significant weakness of Bloom filters and CM sketches.
These advantages are achieved at a considerable increase in implementation complexity.

#### Partitioned Storage {#app-partitioned-storage}

The `PartitionedStorage` exposes the same interface as the basic `Storage`, but supports partitioning the underlying data into disjoint sets.
The API is agnostic to the method of partitioning; all that is required is a number of partitions and an additional parameter specifying the partition in which to store an item while inserting and querying.
The `PartitionedStorage` is template-parameterized with one of the formerly described storage classes, and a number of data structures equal to the number of partitions are constructed.
Thus, care must be taken when using underlying storage classes with a fixed, pre-allocated amount of memory, so as to not overallocate available system memory.
The expected  partitioning method for $k$-mers are minimizer methods, particularly the Universal $k$-mer Hitting Set (UKHS), which is implemented in the `hashing` namespace and described in the streaming sketch chapter.

Partitioned storage offers several advantages, at the cost of increased processing time spent on determining partitions.
For storages with poor cache locality, an appropriately-determined partitioning methodology can reduce cache misses during query and graph traversal.
Partitioning also allows fine-grained per-partition locking of the dBG, and thus efficient parallel algorithms.
Both these advantages necessitate locality-sensitive partitioning methods such as minimizer and UKHS schemes.

### `goetia::dbg`

### `goetia::traversal`

### `goetia::sketches`

### `goetia::`: General Utilities
