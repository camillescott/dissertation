# shmlast: An improved implementation of Conditional Reciprocal Best Hits with LAST and Python {#ref-shmlast}

\chaptermark {shmlast}

\begin{sizepar}{16}{24}
\begin{description}

\item[Chapter Authors]
Camille Scott

\item[DOI]
\url{https://doi.org/10.21105/joss.00142}

\end{description}
\end{sizepar}

shmlast originally grew out of the dammit annotation project.
Primarily, it aims to reimplement Conditional Reciprocal Best Hits algorithm, using the python data science ecosystem and the efficient LAST aligner.
It also includes the classic Reciprocal Best Hits algorithm, which seems often-implemented in hacky scripts that ride along with various annotation projects, but rarely implemented in standalone, maintained software.
It was originally a component of dammit, but the program has clear use as a standalone tool, and so was separated into its own project.
The program was published in JOSS at the above referenced DOI.

## Summary

Conditional Reciprocal Best Hits (CRBH) was originally described by Aubry et al.[@aubry_deep_2014] and
implemented in the [crb-blast](https://github.com/cboursnell/crb-blast) package. CRBH is a method
for finding orthologs between two sets of sequences which builds 
on the traditional Reciprocal Best Hits (RBH) method; it improves RBH by
finding an expect-value cutoff per alignment length, and then selecting non-reciprocal 
alignments which meet the minimum threshold.

Unfortunately, the original implementation uses the relatively slow NCBI BLAST+ 
[@altschul_basic_1990], and is implemented in Ruby, which requires users to leave 
the Python-dominated bioinformatics ecosystem. shmlast makes CRBH available to users in Python, while also greatly improving
performance by using the LAST aligner [@kielbasa_adaptive_2011] for initial homology searches.
Other improvements include outputting the list of cutoffs generated by its model along with a plot
of the decision boundary to aid in quality control, as well as using gnu-parallel [@tange_gnu_2011]
to parallelize execution across multiple cores or nodes in a cluster environment.

## Methods

RBH is a relatively old method for determining orthologs between two sequence databases. Orthology
is distinguished from sequence similarity by descent; while two sequences with high similarity are
likely to have structural of functional homology, they are orthologous if they
share a common ancestor sequence. It is difficult to know for sure whether two sequences are
orthologs, but orthologous groups of sequences are critical for a variety of analyses surrounding
structure, function, and evolution, and particularly, for annotation. As such, many methods have 
been developed for separating high-similarity alignments from their orthologous counterparts. RBH is the regal elder of these
methods, and although it is simplistic compared to newer clustering and graph-based methods, it
remains in wide use due to its low false-positive rate and ease of implementation. It is performed
as follows: given two sets of sequences $A$ and $B$, sequences $a_i \in A$ and $b_j \in B$ are
Reciprocal Best Hits if $b_j$ has the highest scoring sequence alignment in $B$ for $a_i$ and $a_i$
has the highest scoring sequence alignment in $A$ for $b_j$. $a_i$ and $b_j$ then have a high
probability of being orthologs.

While this method works well for finding orthologs between two sets of proteins from different
species, it is less effective for annotating newly assembled transcriptomes from existing protein databases.
Transcriptomes are confounded by alternative splicing, causing several transcripts to share
subsequences, which may prevent RBH detection between a translated transcript and its protein, even
when an orthology relationship exists. Aubry et al., and this implementation, circumvent that
problem by first using the reciprocals to establish a score cutoff for each alignment length, and
then keeping *any* alignment which passes that cutoff. This prevents alignments with
high-likelihood of being orthologs based on sequence identity from being discarded due to the high
specificity of RBH.

## Performance

shmlast benefits immensely from the use of LAST over BLAST. It scales well by using gnu-parallel,
and can be distributed across clusters for particularly large runs.

```{r shmlastperf, results="asis", echo=FALSE, fig.cap="Performance comparison with \\emph{Schizosaccharomyces pombe} as the query transcriptome and \\emph{Nematostella vectensis} as the target proteome.", out.extra="scale=0.75"}
include_graphics("figure/shmlast-perf.pdf")
```

```{r shmlastmodel, results="asis", echo=FALSE, fig.cap="CRBH model generated from the performance comparison. Hits with scores above the blue dotted line will be kept.", out.extra="scale=0.75", out.width="100%"}
include_graphics("figure/sacPom.cdna.fa.x.Nematostella_vectensis.uniprot.pep.fa.crbl.model.plot.pdf")
```
